import { app, BrowserWindow, ipcMain } from 'electron';
import * as fs from 'fs';
import * as path from 'path';
import * as proc from 'child_process';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const cache_dir = path.join(app.getPath("temp"),"gisst");
const resource_dir = path.resolve(__dirname, 'resources');
const config_dir = app.getPath("userData");
const content_dir = path.join(cache_dir, "content");

const createWindow = (): void => {
  //app.setAsDefaultProtocolClient(protocol[, path, args]);
  fs.rmSync(path.join(cache_dir, "saves"), {recursive:true,force:true});
  fs.rmSync(path.join(cache_dir, "states"), {recursive:true,force:true});

  fs.mkdirSync(path.join(cache_dir, "core-options"), {recursive:true});
  fs.mkdirSync(path.join(cache_dir, "saves"), {recursive:true});
  fs.mkdirSync(path.join(cache_dir, "states"), {recursive:true});
  fs.mkdirSync(path.join(cache_dir, "cache"), {recursive:true});
  fs.mkdirSync(path.join(cache_dir, "screenshots"), {recursive:true});
  fs.mkdirSync(path.join(config_dir, "remaps"), {recursive:true});

  fs.rmSync(content_dir, {recursive:true,force:true});
  // TODO replace with downloading from a URL in handle_run_retroarch
  fs.cpSync(path.join(resource_dir,"content"), content_dir, {recursive:true});

  let cfg = fs.readFileSync(path.join(resource_dir, 'ra-config-base.cfg'), {encoding:"utf8"});
  cfg = cfg.replace(/\$RESOURCE/g, resource_dir);
  cfg = cfg.replace(/\$CACHE/g, cache_dir);
  cfg = cfg.replace(/\$CONFIG/g, config_dir);
  fs.writeFileSync(path.join(cache_dir, "retroarch.cfg"),cfg);

  fs.chmodSync(path.join(resource_dir,"binaries","retroarch"),"777");
  //TODO: chmod +x retroarch bin
  
  ipcMain.on('gisst:run', handle_run_retroarch);

  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

function handle_run_retroarch(evt:IpcMainEvent, core:string,content:string,entryState:bool,movie:bool) {
  console.assert(!(entryState && movie), "It is invalid to have both an entry state and play back a movie");
  let content_base = content.substring(0, content.lastIndexOf("."));
  let retro_args = ["-v", "-c", path.join(cache_dir, "retroarch.cfg"), "--appendconfig", path.join(content_dir, "retroarch.cfg"), "-L", core];
  if (entryState) {
    retro_args.push("-e");
    retro_args.push("1");
  }
  if (movie) {
    retro_args.push("-P");
    retro_args.push(path.join(content_dir,"/movie.bsv"));
  } else {
    retro_args.push("-R");
    retro_args.push(path.join(content_dir, "/movie.bsv"));
  }
  retro_args.push(path.join(content_dir, content));
  console.log(retro_args);
  if (entryState) {
    fs.cpSync(path.join(content_dir, "entry_state"), path.join(cache_dir, "states", content_base+".state1.entry"));
  }

  const binary = path.join(resource_dir,"binaries","retroarch");
  const process = proc.spawn(binary, retro_args, {"windowsHide":true,});
  process.stdout.on('data', (data) => console.log("out",data.toString()));
  process.stderr.on('data', (data) => console.log("err",data.toString()));
  process.on('close', (exit_code) => console.log("exit",exit_code));
  process.on('error', (error) => console.error("failed to start RA",error));
}
